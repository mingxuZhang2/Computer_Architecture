# 计算机体系结构第一次仿真实验
## 计算机学院 2113615 张铭徐


### 输入文件处理部分

本次实验拟实现一个MIPS仿真软件，能够接收MIPS的机器码，然后通过模拟寄存器/内存的读取操作实现基本指令。

实验提供了一个外壳$shell.c$，是整个$simulator$的框架，我们需要实现的是$sim.c$，是整体$simulator$的实现函数，我们需要在$process\_instruction$函数中实现所有的指令以及对应的输出。

整体的仿真实验的流程如下所示：

- 实现$process\_instruction$函数
- 使用$asm2hex$工具将$/inputs$中的样例测试输入文件从MIPS汇编转换为二进制的机器码，即实现从后缀为.s到后缀为.x的过程
- 调用对应的文件，测试$simulator$的功能

但是我们可以发现，在$asm2hex$工具中，需要配置$spim$的工具，$spim$是一个开源的MIPS指令模拟器，实际上我们的目的就是使用该工具实现汇编到机器码的转变。我们可以配置对应的$spim$的路径，下载对应工具，但是给出的路径名为$spim447$，无论是我们使用$sudo$ $apt$ $install$ $spim$还是使用给出的链接下载配置，实际上使用的都是已经安装写好的$simulator$，所以在这次实验中，我们并不使用$asm2hex$，而是自行使用命令行工具，使用编译器将.s转换为.x的文件。


mips-linux-gnu-as -march=mips32 -o addiu.o addiu.s

mips-linux-gnu-objcopy -O binary -j .text addiu.o addiu.bin

mv addiu.bin addiu.x

以$addiu$文件为例，我们使用上述命令提取机器码，首先对于第一条指令，我们使用了GNU汇编工具，将汇编文件变为.o文件，使用第二条指令提取.o文件中特定的段，也即.text段，该部分存储了指令对应的机器码，最后使用第三个命令，将.bin文件转存为.x的文件，该文件并非可执行文件，而是一个.data类型的文件，里面仅仅存储了机器码，而不存储一些链接信息。

我们还可以使用obj反汇编工具，对于完整的elf可执行文件，我们可以使用以下指令得到反汇编：

mips-linux-gnu-objdump -D addiu.x > addiu_disassembled.s


而对于我们的例子该方法是失效的，因为我们的.x文件仅仅存储了对应的机器码，所以并不会得到一个完整的反汇编的代码。

在得到addiu.x后，我们可以使用hexdump工具，这个工具可以将文件内容以十六进制的形式显示出来。我们使用以下指令来查看文件内容：

hexdump -C addiu.x

在得到该部分后，我们将addiu.x移动到$/src/sim$ $inputs$文件夹下方，然后执行以下命令：

src/sim inputs/addiu.x

就可以进入MIPS Simulator界面，对于所有的输入文件我们都可以按照这样的流程进行操作，最终得到我们想要的.x后缀文件。接下来我们考虑修改的$shell.c$部分。

### $shell.c$修改部分

在这个部分我们主要介绍$shell.c$修改的部分。我们可以使用原本的$shell.c$文件，但是由于其$load$ $program$函数是根据$spim447$设计的，我们使用自定义的方法得到的.x文件无法被读入进来的，所以我们在这里自定义了一个读入程序码的读入函数。具体函数部分请见$shell.c$文件，我们在这里仅仅介绍一下设计的思路。

实际上，对于读入部分，我们仅仅需要将读入部分的二进制码存储到我们内存中的某个区域(通过$mem\_write\_32$)，然后通过$mem\_read\_32$读取内存中的对应指令。我们使用原本的代码进行读入，读的指令与我们通过$hexdump$看到的指令并不相同，这是因为字节顺序不同导致的。$hexdump$ 默认以大端字节序显示数据，而我们显示的可能是小端字节序。如果字节序不一致，我们需要将读取到的字的字节顺序进行转换。可以使用 $ntohl$ 函数来将网络字节序转换为主机字节序。

$ntohl$ 函数用于将一个32位数从网络字节序转换为主机字节序。网络字节序是大端字节序，而主机字节序取决于操作系统。如果系统是小端字节序，那么这个函数会重新排列字节的顺序。如果系统是大端字节序，那么这个函数不会改变任何东西。

此外，我们在代码中添加了部分调试信息，添加了写入的地址和写入的值以便于测试我们上述的读入函数是否正确。对于整体的$shell.c$的执行流是：首先初始化内存并读入对应的数据流，然后读取$simulator$所需要的指令，我们在这里输入的是$go$，那么就会调用$go$函数，其作用是进行CPU的循环($cycle$函数)，根据一个$bool$类型的变量$RUN\_BIT$来看到底当前文件是否执行完，在原本的$shell.c$中，我没有看到$RUN\_BIT$这一变量被更新，所以就会导致一直在执行$cycle$函数，即无法完成模拟仿真，所以我们在$mem\_read\_32$中加入了一个判断：如果我们读取到的指令是$nop$(全0)，那么就说明我们的文件执行完毕，此时更新$RUN\_BIT$为$FALSE$。

这么做实际上是有一些问题的，如果在某一个MIPS代码中存在了一些其他的$nop$指令，会导致程序过早终止，不过在这里我们我们所用的所有测试样例都没有这个问题发生，所以无伤大雅。


### $sim.c$设计思路

事实上，我们本次实验的重头戏是在$sim.c$中，上述内容仅仅是配置环境以及搞清楚整体$simulator$的执行流，我们实现$sim.c$的过程实际上是对MIPS指令集进行一系列的解析操作。我们考虑MIPS的指令：由于$simulator$实际上是接受32位的二进制的机器码，这32位机器码就决定了我们的模拟器会执行什么样的操作。所以在进行解析之前，我们首先需要熟悉MIPS32位的指令的各个字段：指令在计算机中以二进制机器码的形式存储在内存中。同样是32位的长度，根据不同的功能，我们将指令分为三种类型：

* I型指令：I型指令通常用于实现立即数运算和数据传输等操作，其格式为op $t, $s, imm，其中op表示操作码，$t和$s表示目标寄存器和源寄存器，imm表示一个16位的立即数。常见的I型指令包括addi、lw、sw、andi、ori等。例如，addi $t0, $s0, 100的机器码为0x21080064。

* R型指令：R型指令通常用于实现寄存器之间的运算和移位等操作，其格式为op $d, $s, $t，其中op表示操作码，$d、$s和$t表示目标寄存器、源寄存器和第二个源寄存器。常见的R型指令包括add、sub、and、or、sll、srl等。例如，add $t0, $s0, $s1的机器码为0x02118020。


* J型指令：J型指令通常用于实现无条件跳转操作，其格式为$j$ $target$，其中target表示跳转目标地址。常见的J型指令包括j、jal等。例如，j 0x00400014的机器码为0x0800000d。



| 指令格式   | 字段 | 描述 | 作用和功能 | 位数范围 |
| --- | --- | --- | --- | --- |
| I型指令   | op | 操作码 | 指定该指令的具体操作类型 | 31-26 |
|  | rs | 源寄存器号 | 指定源寄存器的编号 | 25-21 |
|  | rt | 目标寄存器号 | 指定目标寄存器的编号 | 20-16 |
|  | imm | 立即数 | 一个16位的立即数，用于运算或传输等操作 | 15-0 |
| J型指令   | op | 操作码 | 指定该指令的具体操作类型 | 31-26 |
|  | addr | 跳转地址 | 一个26位的跳转地址，用于实现无条件跳转等操作 | 25-0 |
| R型指令   | op | 操作码 | 指定该指令的具体操作类型 | 31-26 |
|  | rs | 源寄存器号 | 指定源寄存器的编号 | 25-21 |
|  | rt | 第二个源寄存器号 | 指定第二个源寄存器的编号 | 20-16 |
|  | rd | 目标寄存器号 | 指定目标寄存器的编号 | 15-11 |
|  | shamt | 移位位数 | 一个5位的位移量，用于实现移位操作等 | 10-6 |
|  | funct | 函数码 | 一个6位的函数码，用于指定具体的操作类型（如加法、逻辑运算等） | 5-0 |

那么基于我们上面讨论的内容，我们可以将指令先做解析，得到对应的opcode，由于对于所有的指令，其opcode都是6位的，所以我们可以先根据opcode，将指令划分为三种类型，然后在每条指令的内部分别用$switch--case$语句模拟对应的指令。

由于我们所要模拟的是MIPS程序的执行过程，所以我们仍然需要考虑如何读取指令以及如何更新：我们在读入操作时，将所有的指令的机器码都写入了内存的相应区域，并且使用了一个长度为32位的数组来模拟MIPS的32个通用寄存器的值，在MIPS的内部，有一个程序计数器$program$ $counter$用于指向当前执行到的指令对应的内存区域，所以我们可以通过$mem\_read\_32(pc)$来读取对应的指令，在每次执行完当前的指令后，可以通过更改$pc$的值来达到访问不同的指令区域的效果。

那么问题接踵而至，我们该如何更新PC的值呢？我们知道，MIPS的指令都是32位的，也就是4字节，且MIPS是按照字节寻址的，所以对于非跳转分支指令，也即如果程序是顺序执行，那么我们更新$pc$时只需要$pc=pc+4$即可；而对于分支跳转指令，则需要将$pc$的值更新为跳转后的目的地址。

对于指令的模拟过程，只需要直接访问寄存器对应的数组，就可以模拟MIPS体系结构计算机对于寄存器的一些操作，所以，以$add$指令为例，我们可以写出一下的代码：

```
uint32_t instruction = mem_read_32(CURRENT_STATE.PC);
uint32_t opcode = (instruction & 0xFC000000) >> 26;
uint32_t funct = instruction & 0x3F;
uint32_t rs = (instruction & 0x03E00000) >> 21;
uint32_t rt = (instruction & 0x001F0000) >> 16;
uint32_t rd = (instruction & 0x0000F800) >> 11;
uint32_t shamt = (instruction & 0x000007C0) >> 6;
NEXT_STATE.REGS[rd] = CURRENT_STATE.REGS[rs] + CURRENT_STATE.REGS[rt];
printf("There is ADD instructions!");
printf("The operands is:%d %d\n",CURRENT_STATE.REGS[rs],CURRENT_STATE.REGS[rt]);
printf("The answer is :%d\n",NEXT_STATE.REGS[rd]);
```

在进行模拟时，同样是更新PC的问题，对于跳转指令(即J型指令)，我们在计算$targetaddress$的时候，假设跳转的目的地址是第10条指令，那计算得到的targetaddress的值是40，但是事实上，我们不可以直接让$pc=targetaddress$，因为我们的内存的起始地址并不是0，所以我们需要令$pc=basic+targetaddress$。在更新PC时，我们引入了一个变量$update$，对于跳转和分支指令，如果跳转了地址，我们就令$update=1$，否则$update=0$，在执行完当前指令后，我们在末尾进行判断，如果$update=1$则不需要$pc=pc+4$，否则则需要执行该操作：

```
if(!update) NEXT_STATE.PC = CURRENT_STATE.PC + 4 ;
```

以上便是我们本次实验的基本设计思想，具体的代码请参考附带的文件内的内容，我们添加了一些中间变量输出以确保我们可以检验代码的正确性。